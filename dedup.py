#!/usr/bin/env python2.7
#
# Identify duplicate files to possibly replace with hard links to save space:
#
#     find /Users/boris -type f | ./dedup.py --scan > boris.txt
#     cat boris.txt | ./dedup.py --analyze
#
# The candidate list generated by those steps should be carefully reviewed
# for safety.  For example, any files under version control or subject to
# modification must be left alone, even if they appear to be duplicates.
#
# When satisfied that only safe files are to be deduped,
#
#     cat boris.txt | ./dedup.py --implement
#
# Note that in the "implement" stage, deduplication messages will be echoed
# in arbitrary order due to parallel execution.
#

import os
import sys
import threading
import subprocess
from collections import defaultdict


# scan params
XARGS_COUNT = 50
MAX_SUBPROCS = 8

# analysis params
MIN_FILE_SIZE = 256*1024
MIN_DEDUP = 2*1024*1024


ts_lock = threading.RLock()


def tsout(msg):
    with ts_lock:
        sys.stdout.write(str(msg))
        sys.stdout.write("\n")


def tserr(msg, lock=threading.RLock()):
    with ts_lock:
        sys.stderr.write(str(msg))
        sys.stderr.write("\n")


subprocs = threading.Semaphore(MAX_SUBPROCS)


SCAN_RESULTS = []


def process(chunk):
    try:
        md5_command = "/sbin/md5 -r".split() + chunk
        md5_raw_results = subprocess.check_output(md5_command)
        md5_results = []
        for i, line in enumerate(md5_raw_results.split("\n")):
            if not line:
                continue
            md5_hash, file_name = line.lstrip().split(None, 1)
            orig_file_name = chunk[i]
            if file_name != orig_file_name:
                tserr("WARNING: Filename not preserved by md5: before '{}', after '{}'.  Skipping.".format(orig_file_name, file_name))
                continue
            sr = os.stat(orig_file_name)
            r = (md5_hash, sr.st_nlink, sr.st_size, orig_file_name)
            md5_results.append(r)
            tsout("{} {} {} {}".format(*r))
        with ts_lock:
            SCAN_RESULTS.extend(md5_results)
    finally:
        subprocs.release()


def enqueue_scan(chunk):
    subprocs.acquire()
    threading.Thread(target=process, args=[chunk]).start()


def scan():
    tserr("Reading filenames from stdin.")
    line_count = 0
    chunk = []
    for line in sys.stdin:
        assert line
        line_count += 1
        line = line[:-1]
        if len(chunk) == XARGS_COUNT:
            enqueue_scan(chunk)
            chunk = []
        chunk.append(line)
    enqueue_scan(chunk)
    for i in xrange(MAX_SUBPROCS):
        subprocs.acquire()
    tserr("Scanned {} files.".format(len(SCAN_RESULTS)))


class MD5Hash(object):

    def __init__(self):
        self.md5_hash = None
        self.files = []
        self.current_size = 0.0
        self.ideal_size = None

    def add_file(self, md5_hash, n_link, size, file_name):
        assert not self.md5_hash or self.md5_hash == md5_hash
        self.md5_hash = md5_hash
        assert not self.ideal_size or self.ideal_size == size
        self.ideal_size = size
        self.files.append((md5_hash, n_link, size, file_name))
        self.current_size += (float(size) / n_link)

    def dedup(self):
        try:
            src = self.files[0]
            for dst in self.files[1:]:
                src_filename = src[3]
                dst_filename = dst[3]
                try:
                    subprocess.check_output(["/usr/bin/cmp", src_filename, dst_filename])
                except:
                    tserr("Skipping due to mismatch: '{}' '{}'".format(src_filename, dst_filename))
                else:
                    subprocess.check_output(["/bin/ln", "-f", src_filename, dst_filename])
                    tsout("Deduplicated '{}' => '{}'".format(dst_filename, src_filename))
        finally:
            subprocs.release()


def enqueue_dedup(md5):
    subprocs.acquire()
    threading.Thread(target=md5.dedup).start()


def optimize(dry_run):
    all_files = defaultdict(MD5Hash)
    files = defaultdict(MD5Hash)
    line_count = 0
    for line in sys.stdin:
        assert line
        line_count += 1
        line = line[:-1]
        md5_hash, n_link, size, file_name = line.split(None, 3)
        n_link = int(n_link)
        size = int(size)
        all_files[md5_hash].add_file(md5_hash, n_link, size, file_name)
        if size < MIN_FILE_SIZE:
            continue
        files[md5_hash].add_file(md5_hash, n_link, size, file_name)
    mb = 1024*1024.0
    operated_upon = []
    for md5 in sorted(files.itervalues(), key=lambda f: f.current_size - f.ideal_size):
        if md5.current_size - md5.ideal_size < MIN_DEDUP:
            continue
        operated_upon.append(md5)
        tsout("")
        tsout("Save {:.1f} MB by deduping\n{}".format((md5.current_size - md5.ideal_size) / mb, "".join(["\n        " + f[3] for f in md5.files])))
        tsout("")
        if not dry_run:
            enqueue_dedup(md5)
    if not dry_run:
        for i in xrange(MAX_SUBPROCS):
            subprocs.acquire()
    ideal = sum(f.ideal_size for f in operated_upon) / mb
    current = sum(f.current_size for f in operated_upon) / mb
    total = sum(f.current_size for f in all_files.itervalues()) / mb
    eligible_count = sum(len(f.files) for f in operated_upon)
    tsout("Parameters: MIN_FILE_SIZE={:3.1f} MB, MIN_DEDUP={:3.1f} MB.".format(MIN_FILE_SIZE/mb, MIN_DEDUP/mb))
    tsout("{} files eligible for deduplication = {:3.1f}% of {} total files.".format(eligible_count, 100.0*eligible_count/line_count, line_count))
    tsout("Space savings {:.0f} MB = {:3.1f}% of {:.0f} MB total space.".format(current - ideal, 100.0*(current - ideal)/max(total,0.00001), total, MIN_DEDUP/mb))


if __name__ == "__main__":
    if len(sys.argv) >= 2 and sys.argv[1].strip('-').lower() == "scan":
        scan()
    elif len(sys.argv) >= 2 and sys.argv[1].strip('-').lower() in ("analyze", "analyse", "analysis"):
        optimize(dry_run=True)
    elif len(sys.argv) >= 2 and sys.argv[1].strip('-').lower() in ("optimize", "optimise", "implement", "implementation"):
        optimize(dry_run=False)
    else:
        tserr("Unsupported command line.")
        sys.exit(-1)
    #tsprint(repr(RESULTS))
